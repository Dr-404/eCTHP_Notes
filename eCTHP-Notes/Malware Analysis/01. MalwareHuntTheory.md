# Hunting Location 
- Hiding in Plain Sight
- Injected into the other process
- In file ( eg. macros)
- In email attachment
- In memory (known as fileless malware) , etc


# Dection Tools

## 1. PE Capture (Paid) tools or PEStudio (Free for personal)
- capture `PE`, `exe`, `DLL`, `drivers`
- Analyze the intercepted and log folders
- Find the indicators of malicious file (eg. rundll32.exe)


## 2. ProcScan.rb
- written in ruby
- Scan process memory and looking for code injection 
- ony x86 not for x86_x64


# Memory Analysis - Important topic

- Before analyze, the memory dump are required. (mapping of physical memory called memory image)


## Two approach for acquiring memory from a physical devices:
- Hardware acquisition 
- Software acquisition
- Non commercial tools - , `FTK Imager`, `DumpIT` and `MAGNET RAM Capture`
- Vmware - `.vmem` file

## How to identify abnomal process

1. Image name  -> legitimate process, spelled correctly?
2. Full Path -> Appropriat path?, running from `temp`? or from a`user`?
3. Parent process -> expected parent?
4. Command line - commandline arguments make sense?
5. Start time - Was the process started at boot?
6. Security Identifier - why system process use user account SID?
7. Any process over port `80`,`443` or `8080` that is `not a web browser`
8. Any browser not communicating over port `80`,`443` or `8080`
9. Web request directly to an IP addresses rather than a domain name
10. RDP connection ( originating from odd IP like IP assigned to printer)
11. why this process have network capability
12. DNS requests for unusual domain names
13. Unlinked process
14. Loaded suspicious DLLs
15. Hooked API function 
16. Know signatures

## Memory analysis tools
- Redline
- Volatility


# What and Why memory forensics?
- Extracting forensic artifacts from the computer RAM
- Memory Store valuable information about runtime state of system
- Help determine
    - Which application are running
    - Active Network Connection
    - Loaded Modules
    - Kernel Drivers

- **Some malware may not write components to disk, only in memory**


# Why `PAGE_EXECUTE_READWRITE` is malicious

- normal process `PAGE_EXECUTE_WRITECOPY`

- Separation of Code and Data:

- A core principle of secure computing is the separation of executable code and data. Memory should either:
Contain executable code (`PAGE_EXECUTE_READ` or `PAGE_EXECUTE_READONLY`) that cannot be modified.
Contain writable data (`PAGE_READWRITE`) that cannot be executed.
- Combining writable and executable permissions violates this principle and opens the door to security vulnerabilities.
Writable and Executable Memory is Risky:

- If a memory region is both writable and executable:
Code can be dynamically written into the memory region.
The written code can then be immediately executed.
This behavior is often exploited by attackers to inject and execute malicious code in a process.




